from pathlib import Path

from pybroma import Class, Root

from broma_ida.broma.constants import BROMA_PLATFORMS
from broma_ida.class_builder.class_builder import ClassBuilder


class BromaCodegen:
    """Codegen for Broma"""

    FILE_HEADER = f"""// Generated by BromaIDA, do not modify
#include <array>

#define BROMAIDA_PLATFORM_MACRO_NAME
#define BROMAIDA_USE_CUSTOM_GNUSTL_MACRO

#define STR_CONCAT_WRAPPER(a, b) a ## b
#define STR_CONCAT(a, b) STR_CONCAT_WRAPPER(a, b)
#define PAD(size) unsigned char STR_CONCAT(__pad, __LINE__)[size]\n\n"""

    _classes: dict[str, Class]
    _path: Path
    _target_platform: BROMA_PLATFORMS
    _use_custom_gnustl: bool = True
    _broma_path: Path

    _added_classes: set[str] = set()

    def __init__(
        self,
        platform: BROMA_PLATFORMS,
        use_custom_gnustl: bool,
        broma_classes: dict[str, Class],
        path: Path,
        broma_path: Path,
    ):
        self._target_platform = platform
        self._use_custom_gnustl = use_custom_gnustl
        self._classes = broma_classes
        self._path = path
        self._broma_path = broma_path

        (self._path / "codegen").mkdir(parents=True, exist_ok=True)

    def write(self):
        """Dumps codegenned classes, structs and enums
        to the path supplied in __init__

        Args:
            path (Path)
        """
        with open(
            self._path / "codegen" / f"{self._target_platform}.hpp",
            "w",
            buffering=10 * 1024 * 1024,
        ) as f:
            f.write(
                self.FILE_HEADER.replace(
                    "BROMAIDA_PLATFORM_MACRO_NAME",
                    self._get_bromaida_platform_macro(),
                ).replace(
                    "BROMAIDA_USE_CUSTOM_GNUSTL_MACRO",
                    "BROMAIDA_USE_CUSTOM_GNUSTL"
                    if self._use_custom_gnustl
                    else "BROMAIDA_DONT_USE_CUSTOM_GNUSTL",
                )
            )

            with open(self._path / "enums.hpp") as enums:
                f.write("// enums.hpp\n")
                f.writelines(enums.readlines())
                f.write("\n\n")

            if self._target_platform.startswith("android"):
                with open(self._path / "gnustl.hpp") as gnustl:
                    f.write("// gnustl.hpp\n")
                    f.writelines(gnustl.readlines())
                    f.write("\n\n")
            else:
                f.write("// standard headers\n")
                for header in (
                    "string",
                    "vector",
                    "map",
                    "unordered_map",
                    "set",
                    "unordered_set",
                ):
                    f.write(f"#include <{header}>\n")
                f.write("\n")

            with open(self._path / "cocos2d.hpp") as cocos:
                f.write("// cocos2d.hpp\n")
                for line in cocos.readlines():
                    if line.startswith('#include "'):
                        line = f"// {line}"

                    f.write(line)
                f.write("\n\n")

            with open(self._path / "fmod.hpp") as fmod:
                f.write("// fmod.hpp\n")
                f.writelines(fmod.readlines())
                f.write("\n\n")

            with open(self._path / "helpers.hpp") as helpers:
                f.write("// helpers.hpp\n")
                f.writelines(helpers.readlines())
                f.write("\n\n")

            f.flush()

            # now we codegen the Broma file
            f.write("// Broma\n\n")

            f.write("// typdefs\n")
            f.write("enum class TodoReturn {}; // :troll:\n")
            f.write("\n")

            f.flush()

            f.write("// class fwddec\n")
            for c in self._classes.keys():
                if "::" in c:
                    split_c = c.split("::")

                    if len(split_c) == 2:
                        f.write(
                            f"""namespace {split_c[0]} {{ class {split_c[1]}; }};\n"""
                        )
                    elif len(split_c) == 3:
                        f.write(
                            f"""namespace {split_c[0]} {{ namespace {split_c[1]} {{ class {split_c[2]}; }} }}\n"""
                        )
                else:
                    f.write(f"class {c};\n")
            f.write("\n")

            f.flush()

            f.write("// extras\n")
            for name, broma_class in (
                Root(str(self._broma_path / "Extras.bro"))
                .classesAsDict()
                .items()
            ):
                f.write(
                    ClassBuilder(self._target_platform, broma_class).get_str()
                )
            f.write("\n")

            f.flush()

            f.write("// delegates and non-polymorphic classes\n")
            for name, broma_class in self._classes.items():
                if len(broma_class.superclasses) != 0:
                    continue

                self._added_classes.add(name)

                f.write(
                    ClassBuilder(self._target_platform, broma_class).get_str()
                )
            f.write("\n")

            f.flush()

            f.write("// classes\n")
            for name, broma_class in self._classes.items():
                if name in self._added_classes:
                    continue

                f.write(
                    ClassBuilder(self._target_platform, broma_class).get_str()
                )
            f.write("\n")

            with open(self._path / "stl_types.hpp") as stl_types:
                f.write("// stl_types.hpp\n")
                for line in stl_types.readlines():
                    if line.startswith('#include "'):
                        line = f"// {line}"

                    f.write(line)

    def _get_bromaida_platform_macro(self) -> str:
        """Gets the BromaIDA platform macro name (shocker)"""
        plat_to_macro_suffix: dict[BROMA_PLATFORMS, str] = {
            "win": "WINDOWS",
            "imac": "INTEL_MACOS",
            "m1": "M1_MACOS",
            "ios": "IOS",
            "android32": "ANDROID32",
            "android64": "ANDROID64",
        }

        return f"""BROMAIDA_PLATFORM_{plat_to_macro_suffix[self._target_platform]}"""
